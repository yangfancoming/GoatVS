# Z: 六大设计原则 
    口诀“开口合里特单依”
    
    开闭原则
    接口隔离原则
    里氏替换原则  Z02
    迪米特法则    Z03
    单一原则
    依赖倒置原则  Z06
   
    总体来说设计模式分为三大类：

#A:创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

    简单工厂模式    A01
    工厂方法模式
    抽象工厂模式
    单例模式        A03
    建造者模式      A04 
    原型模式

#B:结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

    1.适配器模式    B01
    2.装饰器模式    B02  装饰模式  装饰者模式
    3.代理模式      B03
    4.外观模式      B04 ( 门面模式 facade )
    5.桥接模式      B05
    6.组合模式      B06
    7.享元模式      B07
    8.过滤器模式    B08


#C:行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
  
    1.策略模式：     C01
    2.模板方法模式： C02
    3.观察者模式：   C03
    4.迭代子模式
    5.责任链模式：   C05
    6.命令模式：     C06
    7.备忘录模式
    8.状态模式       C08
    9.访问者模式
    10.中介者模式
    11.解释器模式：

#D:其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：

    组合和继承的区别：
    
    继承。继承是给一个类添加行为的比较有效的途径。通过使用继承，可以使得子类在拥有自身方法的同时，还可以拥有父类的方法。但是使用继承是静态的，在编译的时候就已经决定了子类的行为，我们不便于控制增加行为的方式和时机。
    组合。组合即将一个对象嵌入到另一个对象中，由另一个对象来决定是否引用该对象来扩展自己的行为。这是一种动态的方式，我们可以在应用程序中动态的控制。

#E: 补充模式
    1. 回调模式： E01
    
    
# 策略模式总结：  本质是 将接口作为参数进行传递！
    4.1 主要优点
    　　（1）提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择具体算法或行为，也可以灵活地增加新的算法或行为。
    　　（2）避免了多重的if-else条件选择语句，利于系统的维护。
    　　（3）提供了一种算法的复用机制，不同的环境类可以方便地复用这些策略类。
    
    4.2 主要缺点
    　　（1）客户端需要知道所有的策略类，并自行决定使用哪一个策略 => 只适用于客户端了解所有策略算法的情况。
    　　（2）将造成系统产生很多的具体策略类，任何细小的变化都将导致系统要增加一个具体策略类 => 类的个数也许会超出预期。
    　　（3）无法在客户端同时使用多个策略类 => 客户端每次只能使用一个策略类。
    
    4.3 应用场景
    　　（1）如果一个系统要动态地在几种算法之间选择其中一种 => 那就快用策略模式吧骚年！
    　　（2）如果有难以维护的多重if-else条件选择语句是为了实现对象的行为 => 那就快用策略模式吧骚年！
    　　（3）不希望客户知道复杂的与算法有关的数据结构，可以将其封装到策略中 => 提高算法的保密性和安全性！